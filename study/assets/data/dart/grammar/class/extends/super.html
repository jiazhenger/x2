class <i>Animal</i>{
	int <b>key</b>;
	int <b>buy</b>;
	Animal( <b>{ </b><strong> key, buy </strong><b> }</b> ){
		this.<b>key</b> = <strong>key</strong>;
		this.<b>buy</b> = <strong>buy</strong>;
		print(this.<b>key</b>);			<em>// => 100</em>
		print(this.<b>buy</b>);		<em>// => 200</em>
	}
	<em># 简写</em>
	Animal( <b>{ this.key, this.buy }</b> )
}
class <i>Cat</i> <b>extends</b> <i>Animal</i>{
	Cat(<b>{</b> int <s>key</s>,int <s>buy</s> <b>}</b>) 		<em>// 传入可选参数</em>
	<b>:</b> 						<em>// 调用父类构造函数</em>
	super(<strong>key</strong>: <s>key</s>,<strong>buy</strong>: <s>buy</s>);	<em>// 传入参数到父类，相当于调用： <strong>Animal(key:100,buy:200)</strong></em>
}
<i>void</i>  <b>main</b>(){
	<b>Cat</b>( <s>key:100,buy:200</s> )
}
<em>/**</em>
<em>一、作用：</em>
<em> 1、子类和父类的变量，有语义上的冲突时，需要用 <b>super</b> 调用父类的变量（方法，变量）</em>
<em> 2、每个子类的构造方法的第一句，都必须 显示或者隐式通过 <b>super</b> 调用父类的构造方法</em>
<em> 3、隐式调用只能调用，无参的构造方法</em>
<em> 4、如果父类没有无参的构造方法，那么必须使用 <b>super</b> 调用父类的构造方法</em>
<em> 5、通过这样的机制保证了父类的构造方法先执行完毕，然后执行子类的构造方法</em>
<em> 6、通过 <b>super</b> 来访问父类的构造方法，执行的意义在于，对父类实例成员的初始化</em>
<em>*/</em>