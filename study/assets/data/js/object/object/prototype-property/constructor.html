<u># 用法</u>
<em>1、返回创建实例对象的 Object 构造函数的引用，即：指向该对象的构造函数</em>
<em>2、注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。对原始类型来说，如 1，true 和 'test'，该值只可读</em>
<em>3、所有函数最终的构造函数都指向 Function</em>
<u># 语法</u>
<b>Object.prototype.constructor</b>
<u># 返回值</u>
<em>返回对函数本身的引用</em>
<u># 注释</u>
<em>所有对象都会从它的原型上继承一个 constructor 属性</em>
<u># 获取对象的构造函数</u>
<em>function Tree( ) { }</em>
<em>var obj = new Tree( )</em>
<em>console.log(obj.<b>constructor</b>)</em>		<em>// => function Tree( ) { }</em>
<u># 改变对象的构造函数</u>
<em>1、手动设置或更新构造函数可能会导致不同且有时令人困惑的后果</em>
<em>2、为了防止它，只需在每个特定情况下定义构造函数的角色。在大多数情况下，不使用构造函数，并且不需要重新分配构造函数</em>
<em>function Parent( ) { }</em>
<em>function CreatedConstructor( ) { }</em>

<em>CreatedConstructor.prototype = Object.create(Parent.prototype)</em>
<em>CreatedConstructor.prototype.<b>constructor</b> = CreatedConstructor</em> 	<em>// 改变原型对象的构造函数</em>

<em>CreatedConstructor.prototype.create = function create( ) {</em>
	<em>return new this.constructor( )</em>
<em>}</em>

<em>new CreatedConstructor( ).create( ).create( )</em>